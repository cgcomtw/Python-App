# notepad.py
# Cross‑platform (Windows/macOS/Linux) using PySide6. Pack with PyInstaller --onefile.

from PySide6 import QtCore, QtGui, QtWidgets
from PySide6.QtCore import Qt
from PySide6.QtWidgets import (
    QApplication, QMainWindow, QWidget, QVBoxLayout, QHBoxLayout,
    QPushButton, QLabel, QFileDialog, QPlainTextEdit, QDialog, QLineEdit,
    QCheckBox, QGridLayout, QMessageBox, QSizeGrip, QStyle
)
from PySide6.QtGui import QShortcut
import sys
import os

APP_NAME = "Python Notepad"
AUTHOR = "Kelvin Huang"
WEBSITE = "https://www.cg.com.tw"

# ----------------------------
# Custom Dark Title Bar Widget
# ----------------------------
class TitleBar(QWidget):
    height_px = 36

    def __init__(self, parent: QMainWindow):
        super().__init__(parent)
        self.parent = parent
        self.setAutoFillBackground(True)
        self.setFixedHeight(self.height_px)

        # Dark palette
        p = self.palette()
        p.setColor(self.backgroundRole(), QtGui.QColor(24, 24, 24))
        self.setPalette(p)

        # Layout
        self.icon_label = QLabel()
        self.icon_label.setFixedSize(20, 20)
        self.icon_label.setScaledContents(True)
        self.title_label = QLabel()
        self.title_label.setStyleSheet("color: #DADADA; font-weight: 600;")
        self.title_label.setText(APP_NAME)

        btn_style = (
            "QPushButton { border: none; color: #DADADA; padding: 6px 10px; }"
            "QPushButton:hover { background-color: #333; }"
        )
        self.btn_min = QPushButton("–")
        self.btn_max = QPushButton("□")
        self.btn_close = QPushButton("✕")
        for b in (self.btn_min, self.btn_max, self.btn_close):
            b.setStyleSheet(btn_style)
            b.setFixedSize(36, 28)

        self.btn_close.setStyleSheet(
            btn_style + "QPushButton:hover { background-color: #C42B1C; color: white; }"
        )

        h = QHBoxLayout(self)
        h.setContentsMargins(8, 0, 0, 0)
        h.setSpacing(8)
        h.addWidget(self.icon_label)
        h.addWidget(self.title_label, 1)
        h.addWidget(self.btn_min)
        h.addWidget(self.btn_max)
        h.addWidget(self.btn_close)

        # Signals
        self.btn_min.clicked.connect(parent.showMinimized)
        self.btn_max.clicked.connect(self.toggle_max_restore)
        self.btn_close.clicked.connect(parent.close)

        # Dragging
        self._drag_pos = None

    def toggle_max_restore(self):
        if self.parent.isMaximized():
            self.parent.showNormal()
        else:
            self.parent.showMaximized()

    def mouseDoubleClickEvent(self, event: QtGui.QMouseEvent) -> None:
        if event.button() == Qt.LeftButton:
            self.toggle_max_restore()

    def mousePressEvent(self, event: QtGui.QMouseEvent) -> None:
        if event.button() == Qt.LeftButton:
            self._drag_pos = event.globalPosition().toPoint()
            self._start_geom = self.parent.frameGeometry()
        super().mousePressEvent(event)

    def mouseMoveEvent(self, event: QtGui.QMouseEvent) -> None:
        if self._drag_pos is not None:
            delta = event.globalPosition().toPoint() - self._drag_pos
            self.parent.move(self._start_geom.topLeft() + delta)
        super().mouseMoveEvent(event)

    def mouseReleaseEvent(self, event: QtGui.QMouseEvent) -> None:
        self._drag_pos = None
        super().mouseReleaseEvent(event)

    def setWindowTitle(self, title: str):
        self.title_label.setText(title)

    def setWindowIcon(self, icon: QtGui.QIcon):
        self.icon_label.setPixmap(icon.pixmap(20, 20))


# ----------------------------
# Find / Replace Dialog
# ----------------------------
class FindReplaceDialog(QDialog):
    def __init__(self, editor: QPlainTextEdit, parent=None):
        super().__init__(parent)
        self.editor = editor
        self.setWindowTitle("搜尋 / 取代")
        self.setModal(False)
        self.setAttribute(Qt.WA_DeleteOnClose)
        self.setMinimumWidth(420)

        self.find_edit = QLineEdit()
        self.replace_edit = QLineEdit()
        self.case_cb = QCheckBox("區分大小寫")
        self.word_cb = QCheckBox("全字匹配")

        self.btn_find_next = QPushButton("找下一個")
        self.btn_find_prev = QPushButton("找上一個")
        self.btn_replace = QPushButton("取代")
        self.btn_replace_all = QPushButton("全部取代")

        grid = QGridLayout(self)
        grid.addWidget(QLabel("關鍵字："), 0, 0)
        grid.addWidget(self.find_edit, 0, 1, 1, 3)
        grid.addWidget(QLabel("取代為："), 1, 0)
        grid.addWidget(self.replace_edit, 1, 1, 1, 3)
        grid.addWidget(self.case_cb, 2, 1)
        grid.addWidget(self.word_cb, 2, 2)
        grid.addWidget(self.btn_find_prev, 3, 1)
        grid.addWidget(self.btn_find_next, 3, 2)
        grid.addWidget(self.btn_replace, 4, 1)
        grid.addWidget(self.btn_replace_all, 4, 2)

        self.btn_find_next.clicked.connect(self.find_next)
        self.btn_find_prev.clicked.connect(self.find_prev)
        self.btn_replace.clicked.connect(self.replace_one)
        self.btn_replace_all.clicked.connect(self.replace_all)

        # Dark dialog look
        self.setStyleSheet("QDialog{background:#1E1E1E;} QLabel, QCheckBox{color:#DADADA;} QLineEdit{background:#2B2B2B;color:#EEE;border:1px solid #444;padding:4px;} QPushButton{background:#333;color:#EEE;border:1px solid #444;padding:6px 10px;} QPushButton:hover{background:#3d3d3d}")

    def _flags(self):
        flags = QtGui.QTextDocument.FindFlags()
        if self.case_cb.isChecked():
            flags |= QtGui.QTextDocument.FindCaseSensitively
        if self.word_cb.isChecked():
            flags |= QtGui.QTextDocument.FindWholeWords
        return flags

    def find_next(self):
        term = self.find_edit.text()
        if not term:
            return
        if not self.editor.find(term, self._flags()):
            # Wrap search
            cursor = self.editor.textCursor()
            cursor.movePosition(QtGui.QTextCursor.Start)
            self.editor.setTextCursor(cursor)
            self.editor.find(term, self._flags())

    def find_prev(self):
        term = self.find_edit.text()
        if not term:
            return
        flags = self._flags() | QtGui.QTextDocument.FindBackward
        if not self.editor.find(term, flags):
            cursor = self.editor.textCursor()
            cursor.movePosition(QtGui.QTextCursor.End)
            self.editor.setTextCursor(cursor)
            self.editor.find(term, flags)

    def replace_one(self):
        cursor = self.editor.textCursor()
        if cursor.hasSelection():
            cursor.insertText(self.replace_edit.text())
        self.find_next()

    def replace_all(self):
        term = self.find_edit.text()
        if not term:
            return
        repl = self.replace_edit.text()
        doc = self.editor.document()
        cursor = QtGui.QTextCursor(doc)
        count = 0
        flags = self._flags()
        # Start at beginning
        cursor.beginEditBlock()
        cursor.movePosition(QtGui.QTextCursor.Start)
        while True:
            cursor = doc.find(term, cursor, flags)
            if cursor.isNull():
                break
            cursor.insertText(repl)
            count += 1
        cursor.endEditBlock()
        QMessageBox.information(self, "取代完成", f"已取代 {count} 處。")


# ----------------------------
# Main Window (Frameless + Dark)
# ----------------------------
class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()

        # Frameless window with custom title bar
        self.setWindowFlag(Qt.FramelessWindowHint)
        self.setAttribute(Qt.WA_TranslucentBackground, False)
        self._shadow = QtWidgets.QGraphicsDropShadowEffect(blurRadius=12, xOffset=0, yOffset=0)
        self._shadow.setColor(QtGui.QColor(0, 0, 0, 140))
        container = QWidget()
        container.setGraphicsEffect(self._shadow)
        container.setObjectName("container")
        container.setStyleSheet("#container{background:#1E1E1E;border:1px solid #333;border-radius:8px}")

        v = QVBoxLayout(container)
        v.setContentsMargins(1, 1, 1, 1)
        v.setSpacing(0)

        self.title_bar = TitleBar(self)
        v.addWidget(self.title_bar)

        # Central editor
        self.editor = QPlainTextEdit()
        self.editor.setFrameShape(QtWidgets.QFrame.NoFrame)
        self.editor.setWordWrapMode(QtGui.QTextOption.WrapAtWordBoundaryOrAnywhere)
        self.editor.setLineWrapMode(QPlainTextEdit.WidgetWidth)  # 自動換行
        self.editor.setUndoRedoEnabled(True)  # Qt 內建撤銷/重做（深度依系統記憶體）
        # Dark editor palette
        self._apply_dark_palette()
        v.addWidget(self.editor, 1)

        # Resize grip (bottom-right)
        grip = QSizeGrip(self)
        grip.setStyleSheet("background: transparent;")
        griplayout = QHBoxLayout()
        griplayout.addStretch(1)
        griplayout.addWidget(grip, 0, Qt.AlignBottom | Qt.AlignRight)
        v.addLayout(griplayout)

        wrapper = QWidget()
        wrapper.setLayout(v)
        self.setCentralWidget(wrapper)

        # Window geometry
        self.resize(880, 880)
        self._set_window_title(APP_NAME)
        self.setWindowIcon(self.style().standardIcon(QStyle.SP_FileIcon))
        self.title_bar.setWindowIcon(self.windowIcon())

        # Menus & actions
        self._create_actions()
        self._create_menus()

        # Shortcuts (Zoom, Find)
        self._create_shortcuts()

        # File state
        self.current_path = None
        self.zoom_steps = 0

    # --- Appearance ---
    def _apply_dark_palette(self):
        pal = self.editor.palette()
        pal.setColor(QtGui.QPalette.Base, QtGui.QColor(30, 30, 30))
        pal.setColor(QtGui.QPalette.Text, QtGui.QColor(230, 230, 230))
        self.editor.setPalette(pal)
        self.editor.setStyleSheet(
            "QPlainTextEdit{font-family: 'Consolas', 'Menlo', 'Courier New', monospace; font-size: 14px;}"
        )

    def _set_window_title(self, name):
        self.setWindowTitle(name)
        self.title_bar.setWindowTitle(name)

    # --- Menus ---
    def _create_actions(self):
        self.act_new = QtGui.QAction("新增", self)
        self.act_open = QtGui.QAction("開啟…", self)
        self.act_save = QtGui.QAction("儲存", self)
        self.act_save_as = QtGui.QAction("另存新檔…", self)
        self.act_exit = QtGui.QAction("離開", self)

        self.act_undo = QtGui.QAction("復原", self)
        self.act_redo = QtGui.QAction("取消復原", self)
        self.act_cut = QtGui.QAction("剪下", self)
        self.act_copy = QtGui.QAction("複製", self)
        self.act_paste = QtGui.QAction("貼上", self)
        self.act_select_all = QtGui.QAction("全選", self)
        self.act_find_replace = QtGui.QAction("搜尋 / 取代…", self)

        self.act_zoom_in = QtGui.QAction("放大", self)
        self.act_zoom_out = QtGui.QAction("縮小", self)
        self.act_zoom_reset = QtGui.QAction("重設縮放", self)
        self.act_toggle_wrap = QtGui.QAction("切換自動換行", self)
        self.act_toggle_wrap.setCheckable(True)
        self.act_toggle_wrap.setChecked(True)

        self.act_about_dev = QtGui.QAction("關於開發者", self)

        # Shortcuts
        self.act_new.setShortcut("Ctrl+N")
        self.act_open.setShortcut("Ctrl+O")
        self.act_save.setShortcut("Ctrl+S")
        self.act_save_as.setShortcut("Ctrl+Shift+S")
        self.act_exit.setShortcut("Ctrl+Q")

        self.act_undo.setShortcut("Ctrl+Z")
        self.act_redo.setShortcut("Ctrl+Y")
        self.act_cut.setShortcut("Ctrl+X")
        self.act_copy.setShortcut("Ctrl+C")
        self.act_paste.setShortcut("Ctrl+V")
        self.act_select_all.setShortcut("Ctrl+A")
        self.act_find_replace.setShortcut("Ctrl+F")

        # Connections
        self.act_new.triggered.connect(self.file_new)
        self.act_open.triggered.connect(self.file_open)
        self.act_save.triggered.connect(self.file_save)
        self.act_save_as.triggered.connect(self.file_save_as)
        self.act_exit.triggered.connect(self.close)

        self.act_undo.triggered.connect(self.editor.undo)
        self.act_redo.triggered.connect(self.editor.redo)
        self.act_cut.triggered.connect(self.editor.cut)
        self.act_copy.triggered.connect(self.editor.copy)
        self.act_paste.triggered.connect(self.editor.paste)
        self.act_select_all.triggered.connect(self.editor.selectAll)
        self.act_find_replace.triggered.connect(self.show_find_replace)

        self.act_zoom_in.triggered.connect(lambda: self._zoom(+1))
        self.act_zoom_out.triggered.connect(lambda: self._zoom(-1))
        self.act_zoom_reset.triggered.connect(self._zoom_reset)
        self.act_toggle_wrap.triggered.connect(self.toggle_wrap)

        self.act_about_dev.triggered.connect(self.show_about_dev)

    def _create_menus(self):
        # Custom dark menu bar imitation under title bar
        self.menu_bar = QWidget()
        self.menu_bar.setFixedHeight(32)
        self.menu_bar.setObjectName("menu_bar")
        self.menu_bar.setStyleSheet("#menu_bar{background:#232323;border-top:1px solid #2d2d2d;border-bottom:1px solid #2d2d2d}")

        def mk_menu_button(title: str, actions: list[QtGui.QAction]):
            btn = QPushButton(title)
            btn.setStyleSheet(
                "QPushButton{color:#DADADA;background:transparent;border:none;padding:6px 10px;}"
                "QPushButton:hover{background:#2e2e2e;}"
            )
            menu = QtWidgets.QMenu(btn)
            menu.setStyleSheet(
                "QMenu{background:#262626;color:#EEE;border:1px solid #444;}"
                "QMenu::item:selected{background:#3a3a3a;}"
                "QMenu::separator{height:1px;background:#444;margin:4px 8px;}"
            )
            for a in actions:
                if a is None:
                    menu.addSeparator()
                else:
                    menu.addAction(a)
            btn.setMenu(menu)
            return btn

        file_btn = mk_menu_button("檔案", [
            self.act_new, self.act_open, self.act_save, self.act_save_as, None, self.act_exit
        ])
        edit_btn = mk_menu_button("編輯", [
            self.act_undo, self.act_redo, None, self.act_cut, self.act_copy, self.act_paste, self.act_select_all, None, self.act_find_replace
        ])
        view_btn = mk_menu_button("檢視", [
            self.act_zoom_in, self.act_zoom_out, self.act_zoom_reset, None, self.act_toggle_wrap
        ])
        help_btn = mk_menu_button("說明", [
            self.act_about_dev
        ])

        h = QHBoxLayout(self.menu_bar)
        h.setContentsMargins(8, 0, 8, 0)
        h.setSpacing(0)
        for b in (file_btn, edit_btn, view_btn, help_btn):
            h.addWidget(b)
        h.addStretch(1)

        # Insert after title bar
        central_layout: QVBoxLayout = self.centralWidget().layout()
        central_layout.insertWidget(1, self.menu_bar)

    def _create_shortcuts(self):
        # Zoom shortcuts: Ctrl + (= or +), Ctrl -
        QShortcut(QtGui.QKeySequence("Ctrl++"), self, activated=lambda: self._zoom(+1))
        QShortcut(QtGui.QKeySequence("Ctrl+="), self, activated=lambda: self._zoom(+1))
        QShortcut(QtGui.QKeySequence("Ctrl+-"), self, activated=lambda: self._zoom(-1))
        # Find next/prev
        QShortcut(QtGui.QKeySequence("F3"), self, activated=self._find_next_from_cursor)
        QShortcut(QtGui.QKeySequence("Shift+F3"), self, activated=self._find_prev_from_cursor)

    # --- Zoom / Wrap ---
    def _zoom(self, step: int):
        if step > 0:
            self.editor.zoomIn(1)
            self.zoom_steps += 1
        else:
            self.editor.zoomOut(1)
            self.zoom_steps -= 1

    def _zoom_reset(self):
        if self.zoom_steps > 0:
            for _ in range(self.zoom_steps):
                self.editor.zoomOut(1)
        elif self.zoom_steps < 0:
            for _ in range(-self.zoom_steps):
                self.editor.zoomIn(1)
        self.zoom_steps = 0

    def toggle_wrap(self):
        if self.act_toggle_wrap.isChecked():
            self.editor.setLineWrapMode(QPlainTextEdit.WidgetWidth)
        else:
            self.editor.setLineWrapMode(QPlainTextEdit.NoWrap)

    # --- Find/Replace helpers ---
    def show_find_replace(self):
        if not hasattr(self, "_find_dlg") or self._find_dlg is None:
            self._find_dlg = FindReplaceDialog(self.editor, self)
        self._find_dlg.show()
        self._find_dlg.raise_()
        self._find_dlg.activateWindow()

    def _find_next_from_cursor(self):
        if hasattr(self, "_find_dlg") and self._find_dlg:
            self._find_dlg.find_next()

    def _find_prev_from_cursor(self):
        if hasattr(self, "_find_dlg") and self._find_dlg:
            self._find_dlg.find_prev()

    # --- File ops ---
    def file_new(self):
        if self._maybe_save():
            self.editor.clear()
            self.current_path = None
            self._set_window_title(APP_NAME)

    def file_open(self):
        path, _ = QFileDialog.getOpenFileName(self, "開啟檔案", "", "Text Files (*.txt *.md *.log);;All Files (*.*)")
        if path:
            try:
                with open(path, "r", encoding="utf-8") as f:
                    text = f.read()
            except UnicodeDecodeError:
                with open(path, "r", encoding="cp950", errors="ignore") as f:
                    text = f.read()
            self.editor.setPlainText(text)
            self.current_path = path
            self._set_window_title(f"{os.path.basename(path)} — {APP_NAME}")

    def file_save(self):
        if not self.current_path:
            return self.file_save_as()
        try:
            with open(self.current_path, "w", encoding="utf-8") as f:
                f.write(self.editor.toPlainText())
            return True
        except Exception as e:
            QMessageBox.warning(self, "儲存失敗", str(e))
            return False

    def file_save_as(self):
        path, _ = QFileDialog.getSaveFileName(self, "另存新檔", self.current_path or "untitled.txt", "Text Files (*.txt);;All Files (*.*)")
        if path:
            self.current_path = path
            ok = self.file_save()
            if ok:
                self._set_window_title(f"{os.path.basename(path)} — {APP_NAME}")
            return ok
        return False

    def _maybe_save(self):
        if self.editor.document().isModified():
            r = QMessageBox.question(self, "尚未儲存", "是否儲存變更？", QMessageBox.Yes | QMessageBox.No | QMessageBox.Cancel)
            if r == QMessageBox.Yes:
                return self.file_save()
            elif r == QMessageBox.Cancel:
                return False
        return True

    # --- About ---
    def show_about_dev(self):
        QMessageBox.information(
            self,
            "關於開發者",
            f"開發者：{AUTHOR}\n官方網站：{WEBSITE}"
        )

    # --- Native close / maximize in frameless mode ---
    def nativeEvent(self, eventType, message):
        # Keep default behavior; frameless window handled by TitleBar
        return super().nativeEvent(eventType, message)

    # Allow double click in editor to select words etc. (no override needed)

    # --- Close Event ---
    def closeEvent(self, e: QtGui.QCloseEvent) -> None:
        if self._maybe_save():
            e.accept()
        else:
            e.ignore()


# ----------------------------
# Global Dark Application Palette (menus, dialogs)
# ----------------------------
def apply_global_dark(app: QApplication):
    app.setStyle("Fusion")
    dark = QtGui.QPalette()
    dark.setColor(QtGui.QPalette.Window, QtGui.QColor(30, 30, 30))
    dark.setColor(QtGui.QPalette.WindowText, Qt.white)
    dark.setColor(QtGui.QPalette.Base, QtGui.QColor(25, 25, 25))
    dark.setColor(QtGui.QPalette.AlternateBase, QtGui.QColor(45, 45, 45))
    dark.setColor(QtGui.QPalette.ToolTipBase, Qt.white)
    dark.setColor(QtGui.QPalette.ToolTipText, Qt.white)
    dark.setColor(QtGui.QPalette.Text, Qt.white)
    dark.setColor(QtGui.QPalette.Button, QtGui.QColor(45, 45, 45))
    dark.setColor(QtGui.QPalette.ButtonText, Qt.white)
    dark.setColor(QtGui.QPalette.BrightText, Qt.red)
    dark.setColor(QtGui.QPalette.Link, QtGui.QColor(42, 130, 218))
    dark.setColor(QtGui.QPalette.Highlight, QtGui.QColor(64, 128, 255))
    dark.setColor(QtGui.QPalette.HighlightedText, Qt.black)
    app.setPalette(dark)


def main():
    QtCore.QCoreApplication.setAttribute(Qt.AA_EnableHighDpiScaling)
    app = QApplication(sys.argv)
    apply_global_dark(app)
    w = MainWindow()
    # Start centered on screen
    screen = app.primaryScreen().availableGeometry()
    w.move(int((screen.width() - w.width()) / 2), int((screen.height() - w.height()) / 2))
    w.show()
    sys.exit(app.exec())


if __name__ == "__main__":
    main()
