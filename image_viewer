# image_viewer.py

import sys
import subprocess
import importlib
from pathlib import Path

def _auto_install(pkg_name: str, pip_name: str | None = None, min_spec: str | None = None) -> bool:
    if getattr(sys, "frozen", False):
        return False
    target = pip_name or pkg_name
    if min_spec:
        target = f"{target}{min_spec}"
    try:
        print(f"[setup] Installing {target} ...")
        subprocess.check_call([sys.executable, "-m", "pip", "install", target],
                              stdout=sys.stdout, stderr=sys.stderr)
        return True
    except Exception as e:
        print(f"[setup] Install {target} failed: {e}")
        return False

def _require(module_name: str, install_hint: tuple[str, str | None, str | None] | None = None):
    try:
        return importlib.import_module(module_name)
    except ImportError:
        if install_hint is None:
            raise
        pkg_name, pip_name, min_spec = install_hint
        if _auto_install(pkg_name, pip_name, min_spec):
            return importlib.import_module(module_name)
        raise

# === 先確保 PySide6 可用 ===
try:
    _require("PySide6", ("PySide6", None, None))
    from PySide6 import QtCore, QtGui, QtWidgets
    from PySide6.QtCore import Qt, QTimer, QProcess
    from PySide6.QtGui import QPixmap, QAction, QKeySequence, QShortcut
    from PySide6.QtWidgets import (
        QApplication, QMainWindow, QLabel, QScrollArea, QFileDialog, QMessageBox,
        QStatusBar, QLineEdit
    )
except Exception:
    print("缺少 PySide6，且自動安裝失敗或不允許。請手動安裝：pip install PySide6")
    sys.exit(1)

# === Pillow 與 send2trash（缺少時自動安裝；EXE 模式僅提示） ===
try:
    Image = _require("PIL.Image", ("Pillow", "Pillow", ">=10.0"))
    ImageSequence = _require("PIL.ImageSequence")
    ImageOps = _require("PIL.ImageOps")
except Exception:
    QtWidgets.QMessageBox.critical(None, "缺少套件",
                                   "缺少 Pillow，且自動安裝失敗或不允許。\n請手動安裝：pip install Pillow")
    sys.exit(1)

try:
    _require("send2trash", ("send2trash", "send2trash", None))
    from send2trash import send2trash
    SEND2TRASH_AVAILABLE = True
except Exception:
    SEND2TRASH_AVAILABLE = False

import os
import re
import platform

APP_NAME = "Image Viewer (Dark)"
SUPPORTED_EXT = {".jpg", ".jpeg", ".png", ".bmp", ".gif", ".tif", ".tiff", ".webp"}

def human_size(n: int) -> str:
    units = ["B", "KB", "MB", "GB", "TB"]
    s = float(n)
    i = 0
    while s >= 1024 and i < len(units) - 1:
        s /= 1024.0; i += 1
    return f"{s:.1f} {units[i]}"

_num_chunk_re = re.compile(r'(\d+)')
def natural_key(s: str):
    return [int(t) if t.isdigit() else t.lower() for t in _num_chunk_re.split(s)]

def read_image_meta(p: Path):
    with Image.open(p) as im:
        w, h = im.size
        mode = im.mode
        exif = {}
        try:
            exif = dict(im.getexif())
        except Exception:
            pass
        orientation = exif.get(0x0112, 1)
        return w, h, mode, orientation

def apply_exif_orientation(im):
    try:
        return ImageOps.exif_transpose(im)
    except Exception:
        return im

def pil_to_qimage(im):
    im = im.convert("RGBA")
    data = im.tobytes("raw", "RGBA")
    qimg = QtGui.QImage(data, im.width, im.height, QtGui.QImage.Format_RGBA8888)
    return qimg

class APNGPlayer(QtCore.QObject):
    frameChanged = QtCore.Signal(QtGui.QPixmap)
    def __init__(self, parent=None):
        super().__init__(parent)
        self.frames = []
        self.durations = []
        self.index = 0
        self.timer = QTimer(self)
        self.timer.timeout.connect(self._next)
        self.zoom = 1.0

    def load(self, path: Path):
        self.stop()
        self.frames.clear(); self.durations.clear(); self.index = 0
        with Image.open(path) as im:
            if getattr(im, "is_animated", False):
                for frame in ImageSequence.Iterator(im):
                    f = apply_exif_orientation(frame)
                    qimg = pil_to_qimage(f)
                    self.frames.append(qimg)
                    dur = frame.info.get("duration", 100)
                    self.durations.append(max(10, int(dur)))
            else:
                f = apply_exif_orientation(im)
                qimg = pil_to_qimage(f)
                self.frames.append(qimg)
                self.durations.append(0)

    def set_zoom(self, zoom: float):
        self.zoom = max(0.05, min(zoom, 50.0))
        if self.frames:
            self._emit_current()

    def start(self):
        if not self.frames:
            return
        self.timer.stop()
        if len(self.frames) == 1 or all(d == 0 for d in self.durations):
            self._emit_current(); return
        self._emit_current()
        self.timer.start(self.durations[self.index])

    def stop(self):
        self.timer.stop()

    def _emit_current(self):
        qimg = self.frames[self.index]
        if self.zoom != 1.0:
            w = int(qimg.width() * self.zoom); h = int(qimg.height() * self.zoom)
            if w > 0 and h > 0:
                qimg = qimg.scaled(w, h, Qt.KeepAspectRatio, Qt.SmoothTransformation)
        self.frameChanged.emit(QtGui.QPixmap.fromImage(qimg))

    def _next(self):
        if not self.frames:
            return
        self.index = (self.index + 1) % len(self.frames)
        self._emit_current()
        self.timer.start(self.durations[self.index])

def apply_dark_theme(app: QtWidgets.QApplication):
    app.setStyle("Fusion")
    palette = QtGui.QPalette()
    base = QtGui.QColor(32, 34, 37)
    alt  = QtGui.QColor(44, 47, 51)
    text = QtGui.QColor(220, 220, 220)
    hl   = QtGui.QColor(85, 170, 255)
    dis  = QtGui.QColor(90, 90, 90)
    palette.setColor(QtGui.QPalette.Window, base)
    palette.setColor(QtGui.QPalette.WindowText, text)
    palette.setColor(QtGui.QPalette.Base, alt)
    palette.setColor(QtGui.QPalette.AlternateBase, base)
    palette.setColor(QtGui.QPalette.ToolTipBase, alt)
    palette.setColor(QtGui.QPalette.ToolTipText, text)
    palette.setColor(QtGui.QPalette.Text, text)
    palette.setColor(QtGui.QPalette.Button, alt)
    palette.setColor(QtGui.QPalette.ButtonText, text)
    palette.setColor(QtGui.QPalette.BrightText, QtGui.QColor(255, 0, 0))
    palette.setColor(QtGui.QPalette.Highlight, hl)
    palette.setColor(QtGui.QPalette.HighlightedText, QtGui.QColor(0, 0, 0))
    palette.setColor(QtGui.QPalette.Disabled, QtGui.QPalette.Text, dis)
    palette.setColor(QtGui.QPalette.Disabled, QtGui.QPalette.ButtonText, dis)
    palette.setColor(QtGui.QPalette.Disabled, QtGui.QPalette.WindowText, dis)
    palette.setColor(QtGui.QPalette.Disabled, QtGui.QPalette.HighlightedText, dis)
    app.setPalette(palette)
    app.setStyleSheet("""
    QMainWindow { background: #202225; }
    QStatusBar { background: #2c2f33; color: #dcdcdc; }
    QStatusBar QLabel { padding: 0 8px; }
    QLineEdit {
        background: #202225; color: #dcdcdc; border: 1px solid #3a3f44;
        border-radius: 4px; padding: 3px 6px;
    }
    QScrollArea { background: #202225; border: none; }
    QLabel { color: #dcdcdc; }
    QMessageBox { background-color: #2c2f33; }
    """)

class ImageViewer(QtWidgets.QMainWindow):
    def __init__(self, start_path: Path | None = None):
        super().__init__()
        QtWidgets.QApplication.setApplicationName(APP_NAME)
        self.setWindowTitle(APP_NAME)
        self.resize(900, 700)
        # 啟動即最大化（非全螢幕，有標題列）
        self.setWindowState(Qt.WindowMaximized)

        # 中央顯示
        self.image_label = QtWidgets.QLabel(alignment=QtCore.Qt.AlignCenter)
        self.image_label.setScaledContents(False)

        self.scroll = QtWidgets.QScrollArea()
        self.scroll.setWidget(self.image_label)
        self.scroll.setWidgetResizable(True)
        self.setCentralWidget(self.scroll)

        # 狀態列
        self.status = QtWidgets.QStatusBar()
        self.setStatusBar(self.status)
        self.lb_index = QtWidgets.QLabel("0 / 0")
        self.lb_name  = QtWidgets.QLabel("-")
        self.lb_size  = QtWidgets.QLabel("-")
        self.lb_dims  = QtWidgets.QLabel("-")
        self.lb_zoom  = QtWidgets.QLabel("100%")
        self.lb_mode  = QtWidgets.QLabel("-")
        for w in (self.lb_index, self.lb_name, self.lb_size, self.lb_dims, self.lb_zoom, self.lb_mode):
            self.status.addPermanentWidget(w)

        # 狀態列「檔名快速修改模式」
        self.rename_edit = QtWidgets.QLineEdit()
        self.rename_edit.hide()
        self.rename_edit.returnPressed.connect(self._inline_rename_commit)
        self.rename_edit.editingFinished.connect(self._inline_rename_cancel_if_hidden)
        self.status.insertPermanentWidget(1, self.rename_edit)

        # 狀態
        self.files: list[Path] = []
        self.idx = -1
        self.current_pixmap: QtGui.QPixmap | None = None
        self.current_movie: QtGui.QMovie | None = None
        self.apng_player = APNGPlayer()
        self.apng_player.frameChanged.connect(self._on_apng_frame)

        self.zoom = 1.0
        self.fit_mode = True  # 變更：預設自動貼合
        self.current_meta = {"w": 0, "h": 0, "mode": "-", "size": 0}

        # 設定儲存：Photoshop 路徑（Windows）
        self.settings = QtCore.QSettings("PicViewer", "ImageViewer")

        # 啟動載入
        if start_path and start_path.exists():
            self._open_and_index(start_path)
        else:
            self._choose_and_open()

        self._build_actions()

    # ===== 檔案流程 =====
    def _choose_and_open(self):
        file_path, _ = QtWidgets.QFileDialog.getOpenFileName(
            self, "選擇圖片", str(Path.home()),
            "Images (*.jpg *.jpeg *.png *.bmp *.gif *.tif *.tiff *.webp);;All Files (*.*)")
        if file_path:
            self._open_and_index(Path(file_path))
        else:
            QtCore.QTimer.singleShot(0, self.close)

    def _open_and_index(self, p: Path):
        folder = p.parent
        candidates = [f for f in folder.iterdir() if f.is_file() and f.suffix.lower() in SUPPORTED_EXT]
        candidates.sort(key=lambda x: natural_key(x.name))
        self.files = candidates
        try:
            self.idx = self.files.index(p)
        except ValueError:
            self.files.insert(0, p); self.idx = 0
        self._load_current()

    def _load_current(self):
        if not self.files or self.idx < 0 or self.idx >= len(self.files):
            return
        p = self.files[self.idx]
        self._stop_animation()

        try:
            w, h, mode, _ = read_image_meta(p)
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "讀取失敗", f"無法讀取圖片：\n{p}\n\n{e}")
            return

        self.current_meta.update({"w": w, "h": h, "mode": mode, "size": p.stat().st_size if p.exists() else 0})

        ext = p.suffix.lower()
        if ext == ".gif":
            self._load_gif(p)
        elif ext == ".png":
            try:
                with Image.open(p) as im:
                    if getattr(im, "is_animated", False):
                        self._load_apng(p)
                    else:
                        self._load_static(p)
            except Exception:
                self._load_static(p)
        else:
            self._load_static(p)

        # 變更：每次換圖自動貼合視窗
        self.fit_mode = True
        self._maybe_fit()
        self._update_title_and_status()

    def _load_static(self, p: Path):
        with Image.open(p) as im:
            im = apply_exif_orientation(im)
            qimg = pil_to_qimage(im)
        pm = QtGui.QPixmap.fromImage(qimg)
        self.current_pixmap = pm
        self.image_label.setMovie(None)
        self.image_label.setPixmap(self._scaled_pixmap(pm))

    def _load_gif(self, p: Path):
        movie = QtGui.QMovie(str(p))
        movie.setCacheMode(QtGui.QMovie.CacheAll)
        self.current_movie = movie
        self.image_label.setMovie(movie)
        movie.start()

    def _load_apng(self, p: Path):
        self.apng_player.load(p)
        self.apng_player.set_zoom(self.zoom)
        self.image_label.setMovie(None)
        self.apng_player.start()

    def _on_apng_frame(self, pm: QtGui.QPixmap):
        self.current_pixmap = pm
        self.image_label.setPixmap(pm)

    def _stop_animation(self):
        if self.current_movie:
            self.current_movie.stop()
            self.current_movie = None
        self.apng_player.stop()

    # ===== UI 輔助 / 貼合 =====
    def _natural_size(self) -> QtCore.QSize:
        return QtCore.QSize(self.current_meta.get("w", 0), self.current_meta.get("h", 0))

    def _scaled_pixmap(self, pm: QtGui.QPixmap) -> QtGui.QPixmap:
        if not pm or pm.isNull():
            return pm
        if self.fit_mode:
            avail = self.scroll.viewport().size()
            return pm.scaled(avail, QtCore.Qt.KeepAspectRatio, QtCore.Qt.SmoothTransformation)
        if self.zoom != 1.0:
            w = int(pm.width() * self.zoom); h = int(pm.height() * self.zoom)
            if w > 0 and h > 0:
                return pm.scaled(w, h, QtCore.Qt.KeepAspectRatio, QtCore.Qt.SmoothTransformation)
        return pm

    def _maybe_fit(self):
        natural = self._natural_size()
        if not natural.isValid():
            return
        if self.fit_mode:
            avail = self.scroll.viewport().size()
            if avail.width() > 0 and avail.height() > 0 and natural.width() > 0 and natural.height() > 0:
                scale = min(avail.width()/natural.width(), avail.height()/natural.height())
                self.zoom = max(0.05, scale)
                if self.current_movie:
                    scaled = QtCore.QSize(int(natural.width()*self.zoom), int(natural.height()*self.zoom))
                    self.current_movie.setScaledSize(scaled)
                elif self.current_pixmap:
                    self.image_label.setPixmap(self._scaled_pixmap(self.current_pixmap))
            self._update_status_bar_zoom()

    def resizeEvent(self, event):
        super().resizeEvent(event)
        if self.fit_mode:
            self._maybe_fit()

    def _update_title_and_status(self):
        name = self.files[self.idx].name if (0 <= self.idx < len(self.files)) else "-"
        self.setWindowTitle(f"{APP_NAME} - {name}")
        self._update_status_bar_all()

    def _update_status_bar_all(self):
        total = len(self.files)
        cur = self.idx + 1 if self.idx >= 0 else 0
        self.lb_index.setText(f"{cur} / {total}")

        name = self.files[self.idx].name if (0 <= self.idx < total) else "-"
        self.lb_name.setText(name)

        size = human_size(self.current_meta.get("size", 0))
        self.lb_size.setText(size)

        w = self.current_meta.get("w", 0); h = self.current_meta.get("h", 0)
        self.lb_dims.setText(f"{w}×{h}")

        self._update_status_bar_zoom()
        self.lb_mode.setText(self.current_meta.get("mode", "-"))

        if 0 <= self.idx < total and not self.rename_edit.isVisible():
            self.rename_edit.setText(Path(name).stem)

    def _update_status_bar_zoom(self):
        self.lb_zoom.setText(f"{round(self.zoom*100)}%")

    # ===== 導覽 =====
    def _goto(self, new_idx: int):
        if not self.files:
            return
        new_idx = max(0, min(new_idx, len(self.files)-1))
        if new_idx != self.idx:
            self.idx = new_idx
            self._load_current()

    def _next(self):
        if self.files:
            self._goto((self.idx + 1) % len(self.files))

    def _prev(self):
        if self.files:
            self._goto((self.idx - 1 + len(self.files)) % len(self.files))

    # ===== 縮放 =====
    def _set_zoom(self, z: float, refit_if_fit=False):
        z = max(0.05, min(z, 50.0))
        self.zoom = z
        if self.current_movie:
            natural = self._natural_size()
            if natural:
                scaled = QtCore.QSize(int(natural.width()*z), int(natural.height()*z))
                self.current_movie.setScaledSize(scaled)
        else:
            if self.current_pixmap:
                self.image_label.setPixmap(self._scaled_pixmap(self.current_pixmap))
        self._update_status_bar_zoom()
        if self.apng_player:
            self.apng_player.set_zoom(self.zoom)
        if self.fit_mode and refit_if_fit:
            self._maybe_fit()

    def _zoom_in(self):
        self.fit_mode = False
        self._set_zoom(self.zoom * 1.25)

    def _zoom_out(self):
        self.fit_mode = False
        self._set_zoom(self.zoom / 1.25)

    def _zoom_100(self):
        self.fit_mode = False
        self._set_zoom(1.0)

    def _zoom_fit(self):
        self.fit_mode = True
        self._maybe_fit()

    # ===== 更名 / 刪除 =====
    def _rename_dialog(self):
        if not self.files:
            return
        cur = self.files[self.idx]
        new_name, ok = QtWidgets.QInputDialog.getText(
            self, "重新命名 (僅檔名，不改副檔名)", "新檔名（不含副檔名）:", text=cur.stem)
        if not ok or not new_name.strip():
            return
        new_path = cur.with_name(new_name.strip() + cur.suffix)
        if new_path.exists():
            btn = QtWidgets.QMessageBox.question(
                self, "檔名已存在", f"要覆蓋已存在的檔案嗎？\n{new_path.name}",
                QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No, QtWidgets.QMessageBox.No)
            if btn != QtWidgets.QMessageBox.Yes:
                return
        try:
            cur.rename(new_path)
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "重新命名失敗", str(e)); return
        self.files[self.idx] = new_path
        self._reload_folder_keep_index()

    def _inline_rename_toggle(self):
        if not self.files:
            return
        if self.rename_edit.isVisible():
            self._inline_rename_commit()
        else:
            self.rename_edit.setText(self.files[self.idx].stem)
            self.rename_edit.show(); self.rename_edit.setFocus(); self.rename_edit.selectAll()

    def _inline_rename_commit(self):
        if not self.files or not self.rename_edit.isVisible():
            return
        new_stem = self.rename_edit.text().strip()
        if not new_stem:
            self.rename_edit.hide(); return
        cur = self.files[self.idx]
        new_path = cur.with_name(new_stem + cur.suffix)
        if new_path == cur:
            self.rename_edit.hide(); return
        if new_path.exists():
            btn = QtWidgets.QMessageBox.question(
                self, "檔名已存在", f"要覆蓋已存在的檔案嗎？\n{new_path.name}",
                QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No, QtWidgets.QMessageBox.No)
            if btn != QtWidgets.QMessageBox.Yes:
                return
        try:
            cur.rename(new_path)
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "重新命名失敗", str(e)); return
        self.files[self.idx] = new_path
        self.rename_edit.hide()
        self._reload_folder_keep_index()

    def _inline_rename_cancel_if_hidden(self):
        if self.rename_edit.isVisible():
            self.rename_edit.hide()

    def _delete_file(self):
        if not self.files:
            return
        cur = self.files[self.idx]
        if not SEND2TRASH_AVAILABLE:
            QtWidgets.QMessageBox.warning(self, "缺少 send2trash",
                "未安裝 send2trash，無法丟到資源回收桶。\n"
                "程式已嘗試自動安裝但可能失敗。\n請手動安裝：pip install send2trash")
            return
        btn = QtWidgets.QMessageBox.question(
            self, "刪除確認", f"要將此檔案丟到資源回收桶嗎？\n{cur.name}",
            QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No, QtWidgets.QMessageBox.No)
        if btn != QtWidgets.QMessageBox.Yes:
            return

        next_idx = self.idx
        if len(self.files) > 1:
            next_idx = min(self.idx, len(self.files)-2)

        try:
            send2trash(str(cur))
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "刪除失敗", str(e)); return

        del self.files[self.idx]
        if not self.files:
            self.image_label.clear()
            self.setWindowTitle(APP_NAME)
            self._update_status_bar_all()
            return
        self.idx = max(0, min(next_idx, len(self.files)-1))
        self._reload_folder_keep_index()

    def _reload_folder_keep_index(self):
        if not self.files:
            return
        cur = self.files[self.idx]
        folder = cur.parent
        candidates = [f for f in folder.iterdir() if f.is_file() and f.suffix.lower() in SUPPORTED_EXT]
        candidates.sort(key=lambda x: natural_key(x.name))
        self.files = candidates
        try:
            self.idx = self.files.index(cur)
        except ValueError:
            self.idx = max(0, min(self.idx, len(self.files)-1))
        self._load_current()

    # ===== Photoshop 方案 A =====
    def _get_photoshop_path_windows(self) -> str | None:
        path = self.settings.value("photoshop_path", type=str)
        if path and Path(path).exists():
            return path
        # 讓使用者選 Photoshop.exe，記住設定
        exe, _ = QtWidgets.QFileDialog.getOpenFileName(
            self, "選擇 Photoshop.exe", "C:\\Program Files\\Adobe",
            "Photoshop (Photoshop.exe);;可執行檔 (*.exe);;所有檔案 (*.*)")
        if exe and Path(exe).exists():
            self.settings.setValue("photoshop_path", exe)
            return exe
        return None

    def _open_in_photoshop(self):
        if not self.files:
            return
        p = str(self.files[self.idx])
        system = platform.system().lower()
        if "windows" in system:
            ps_path = self._get_photoshop_path_windows()
            if not ps_path:
                QtWidgets.QMessageBox.warning(self, "找不到 Photoshop",
                    "請選擇 Photoshop.exe（或事後在設定中指定）。")
                return
            ok = QProcess.startDetached(ps_path, [p])
            if not ok:
                QtWidgets.QMessageBox.critical(self, "啟動失敗", "無法啟動 Photoshop。")
        elif "darwin" in system:  # macOS
            ok = QProcess.startDetached("/usr/bin/open", ["-b", "com.adobe.Photoshop", p])
            if not ok:
                QtWidgets.QMessageBox.critical(self, "啟動失敗", "無法以 Photoshop 開啟檔案。")
        else:
            QtWidgets.QMessageBox.information(self, "不支援的平台",
                "此功能目前針對 Windows 與 macOS 設計。")

    # ===== 快捷鍵 / 全域綁定 =====
    def _build_actions(self):
        # 既有：0 / F
        QShortcut(QKeySequence("0"), self, activated=self._zoom_100)
        QShortcut(QKeySequence("F"), self, activated=self._zoom_fit)

        # 導覽：確保無論焦點位置都有效
        QShortcut(QKeySequence(Qt.Key_PageUp),   self, activated=self._prev)
        QShortcut(QKeySequence(Qt.Key_PageDown), self, activated=self._next)
        QShortcut(QKeySequence(Qt.Key_Home),     self, activated=lambda: self._goto(0))
        QShortcut(QKeySequence(Qt.Key_End),      self, activated=lambda: self._goto(len(self.files)-1))

        # Photoshop（方案 A）
        QShortcut(QKeySequence("Ctrl+E"), self, activated=self._open_in_photoshop)

        # Esc 關閉
        QShortcut(QKeySequence(Qt.Key_Escape), self, activated=self.close)

    def keyPressEvent(self, event: QtGui.QKeyEvent):
        key = event.key(); mods = event.modifiers()
        if key == QtCore.Qt.Key_F2:        self._rename_dialog(); return
        if mods == QtCore.Qt.ControlModifier and key == QtCore.Qt.Key_R:
            self._inline_rename_toggle(); return
        if key == QtCore.Qt.Key_Delete:    self._delete_file(); return
        if key in (QtCore.Qt.Key_Plus, QtCore.Qt.Key_Equal): self._zoom_in(); return
        if key == QtCore.Qt.Key_Minus:     self._zoom_out(); return
        if key == QtCore.Qt.Key_0:         self._zoom_100(); return
        if key == QtCore.Qt.Key_F:         self._zoom_fit(); return
        super().keyPressEvent(event)

def main():
    app = QtWidgets.QApplication(sys.argv)
    apply_dark_theme(app)
    start_path = Path(sys.argv[1]) if len(sys.argv) >= 2 else None
    win = ImageViewer(start_path if start_path and start_path.exists() else None)
    win.show()
    sys.exit(app.exec())

if __name__ == "__main__":
    main()
