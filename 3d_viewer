# 3d_viewer.py
# 需求：Python 3.9+。首次執行會自動安裝 PySide6 與 PySide6-Qt3D
# 功能：
# - 載入 OBJ/FBX（Qt3D QSceneLoader）
# - 1600x1200 深色主題
# - 滑鼠：左旋轉 / 中平移 / 右拉近遠（拖曳）；滾輪縮放
# - 快捷鍵：Home/End/PageUp/PageDown、ESC、F2（重新命名）
# - 左下角資訊（索引/總數、檔案大小）；標題顯示「3D Viewer – 檔名」

import sys, os, math, ctypes, subprocess, importlib.util, time

# ------------------------ auto install packages ------------------------
def ensure_package(pkg: str):
    if importlib.util.find_spec(pkg) is None:
        print(f"[setup] Installing {pkg} ...")
        python_exe = sys.executable
        subprocess.check_call([python_exe, "-m", "pip", "install", "--upgrade", pkg])

def ensure_qt3d():
    # PySide6 is needed first
    ensure_package("PySide6")
    # Qt3D is split out since PySide6 6.7+
    ensure_package("PySide6-Qt3D")

try:
    ensure_qt3d()
except Exception as e:
    print("[setup] Auto installation failed:", e)
    print("[setup] Trying to continue if already installed...")

# After installation, import Qt modules
from PySide6.QtCore import Qt, QUrl, QSize, QPoint, QTimer, Signal, QObject, QEvent
from PySide6.QtGui import QPalette, QColor, QAction, QKeySequence, QPainter, QFont
from PySide6.QtWidgets import (
    QApplication, QWidget, QFileDialog, QVBoxLayout, QLabel, QMessageBox, QInputDialog
)

# Qt3D modules (require PySide6-Qt3D)
try:
    from PySide6.Qt3DCore import QEntity, QTransform
    from PySide6.Qt3DExtras import Qt3DWindow, QPhongMaterial
    from PySide6.Qt3DRender import QSceneLoader
except Exception as e:
    raise ImportError("Qt3D modules are unavailable. Please ensure PySide6-Qt3D is installed. "
                      "Try: pip install PySide6-Qt3D") from e

# ------------------------ helpers ------------------------
SUPPORTED_EXTS = {".obj", ".fbx"}

def human_size(n: int) -> str:
    units = ["B", "KB", "MB", "GB", "TB"]
    f = float(n)
    for u in units:
        if f < 1024.0:
            return f"{f:.2f} {u}"
        f /= 1024.0
    return f"{f:.2f} PB"

def list_3d_files(folder: str):
    items = []
    try:
        for name in os.listdir(folder):
            p = os.path.join(folder, name)
            ext = os.path.splitext(name)[1].lower()
            if os.path.isfile(p) and ext in SUPPORTED_EXTS:
                items.append(p)
    except Exception:
        pass
    items.sort(key=lambda s: s.lower())
    return items

# ------------------------ Overlay widget ------------------------
class Overlay(QWidget):
    """半透明左下角資訊疊層。"""
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setAttribute(Qt.WA_TransparentForMouseEvents, True)
        self.text = ""
        self.setAutoFillBackground(False)

    def set_text(self, s: str):
        self.text = s
        self.update()

    def paintEvent(self, event):
        if not self.text:
            return
        p = QPainter(self)
        p.setRenderHint(QPainter.Antialiasing, True)
        margin = 12
        # 設定字體
        f = QFont()
        f.setPointSize(11)
        p.setFont(f)
        # 底色框
        metrics = p.fontMetrics()
        lines = self.text.split("\n")
        w = max(metrics.horizontalAdvance(line) for line in lines) + 2 * margin
        h = metrics.height() * len(lines) + 2 * margin
        x, y = 10, self.height() - h - 10
        p.setBrush(QColor(0, 0, 0, 140))
        p.setPen(Qt.NoPen)
        p.drawRoundedRect(x, y, w, h, 8, 8)
        # 文字
        p.setPen(QColor(230, 230, 230))
        ty = y + margin + metrics.ascent()
        for line in lines:
            p.drawText(x + margin, ty, line)
            ty += metrics.height()
        p.end()

# ------------------------ 3D Viewer ------------------------
class Viewer(QWidget):
    def __init__(self, start_file: str, parent=None):
        super().__init__(parent)

        # 主體：Qt3DWindow -> QWidget 容器
        self.view = Qt3DWindow()
        self.view.defaultFrameGraph().setClearColor(QColor(16, 16, 18))
        self.container = self.createWindowContainer(self.view)
        self.container.setFocusPolicy(Qt.StrongFocus)

        lay = QVBoxLayout(self)
        lay.setContentsMargins(0, 0, 0, 0)
        lay.addWidget(self.container)

        # overlay
        self.overlay = Overlay(self)
        self.overlay.raise_()

        # 場景根節點
        self.root = QEntity()
        self.view.setRootEntity(self.root)

        # 相機參數（手寫軌跡球控制）
        self.cam = self.view.camera()
        self.cam.lens().setPerspectiveProjection(45.0, 1600/1200, 0.1, 5000.0)

        # 相機球座標（距離 r、水平角 theta、仰角 phi）
        self.cam_target = [0.0, 0.0, 0.0]
        self.cam_r = 6.0
        self.cam_theta = math.radians(30.0)  # 水平角
        self.cam_phi = math.radians(20.0)    # 仰角
        self.update_camera()

        # 模型載入節點
        self.model_entity = None
        self.loader = None

        # 檔案清單管理
        self.current_file = os.path.abspath(start_file)
        self.folder = os.path.dirname(self.current_file)
        self.files = list_3d_files(self.folder)
        if self.current_file not in [os.path.abspath(p) for p in self.files]:
            self.files.append(self.current_file)
            self.files.sort(key=lambda s: s.lower())

        # 滑鼠狀態
        self.last_pos = QPoint()
        self.drag_mode = None  # 'rotate' | 'pan' | 'dolly'

        # UI 顏色（深色）
        self.apply_dark_palette()

        # 初始載入
        self.load_file(self.current_index())

        # 讓 overlay 尺寸追隨
        self.container.installEventFilter(self)

        # 標題
        self.update_title()

    # ---------- UI / Palette ----------
    def apply_dark_palette(self):
        pal = QPalette()
        pal.setColor(QPalette.Window, QColor(16, 16, 18))
        pal.setColor(QPalette.Base, QColor(30, 30, 32))
        pal.setColor(QPalette.AlternateBase, QColor(40, 40, 44))
        pal.setColor(QPalette.Text, QColor(230, 230, 230))
        pal.setColor(QPalette.Button, QColor(40, 40, 44))
        pal.setColor(QPalette.ButtonText, QColor(230, 230, 230))
        pal.setColor(QPalette.WindowText, QColor(230, 230, 230))
        pal.setColor(QPalette.Highlight, QColor(90, 120, 210))
        pal.setColor(QPalette.HighlightedText, QColor(255, 255, 255))
        self.setPalette(pal)

    # ---------- camera math ----------
    def update_camera(self):
        # 限制仰角避免翻轉
        eps = 1e-3
        self.cam_phi = max(eps, min(math.pi - eps, self.cam_phi))
        # 距離限制
        self.cam_r = max(0.05, min(10000.0, self.cam_r))

        # 球座標 -> 直角座標
        x = self.cam_target[0] + self.cam_r * math.cos(self.cam_phi) * math.cos(self.cam_theta)
        y = self.cam_target[1] + self.cam_r * math.sin(self.cam_phi)
        z = self.cam_target[2] + self.cam_r * math.cos(self.cam_phi) * math.sin(self.cam_theta)
        self.cam.setPosition([x, y, z])
        self.cam.setViewCenter(self.cam_target)

    def camera_axes(self):
        pos = self.cam.position()
        cen = self.cam.viewCenter()
        fwd = normalize(subv(cen, pos))
        right = normalize(cross(fwd, [0, 1, 0]))
        up = normalize(cross(right, fwd))
        return right, up, fwd

    # ---------- file ops ----------
    def current_index(self):
        abspaths = [os.path.abspath(p) for p in self.files]
        try:
            return abspaths.index(os.path.abspath(self.current_file))
        except ValueError:
            return 0

    def set_current_by_index(self, idx: int):
        if not self.files:
            return
        idx = max(0, min(len(self.files)-1, idx))
        self.current_file = os.path.abspath(self.files[idx])
        self.load_file(idx)
        self.update_title()

    def next_file(self):
        self.set_current_by_index(self.current_index() + 1)

    def prev_file(self):
        self.set_current_by_index(self.current_index() - 1)

    def first_file(self):
        self.set_current_by_index(0)

    def last_file(self):
        self.set_current_by_index(len(self.files) - 1)

    def update_title(self):
        base = os.path.basename(self.current_file)
        self.window().setWindowTitle(f"3D Viewer – {base}")

    def update_overlay_info(self):
        idx = self.current_index() + 1
        total = len(self.files)
        size = human_size(os.path.getsize(self.current_file)) if os.path.exists(self.current_file) else "N/A"
        self.overlay.set_text(f"{idx} / {total}\n{size}")

    def load_file(self, idx: int):
        # 清掉舊模型
        if self.model_entity is not None:
            try:
                self.model_entity.setParent(None)
            except Exception:
                pass
            self.model_entity = None
            self.loader = None

        path = self.files[idx]
        self.current_file = path

        # 建一個新的載入節點
        self.model_entity = QEntity(self.root)
        self.loader = QSceneLoader(self.model_entity)
        self.loader.statusChanged.connect(self.on_loader_status)
        url = QUrl.fromLocalFile(path)
        self.loader.setSource(url)

        # 預設材質（避免無材質時全黑）
        self.fallback_mat = QPhongMaterial(self.model_entity)
        self.fallback_mat.setDiffuse(QColor(180, 180, 190))

        self.update_overlay_info()
        # 重置相機（簡易居中）
        self.cam_r = 6.0
        self.cam_theta = math.radians(30)
        self.cam_phi = math.radians(20)
        self.cam_target = [0.0, 0.6, 0.0]
        self.update_camera()

    def on_loader_status(self, status):
        if status == QSceneLoader.Ready:
            # 載入完成；此處可做材質補救或包圍盒計算（省略）
            pass
        elif status == QSceneLoader.Error:
            QMessageBox.warning(self, "載入失敗", f"無法載入檔案：\n{self.current_file}")

    # ---------- mouse / key events ----------
    def eventFilter(self, obj, event):
        if obj is self.container:
            if event.type() == QEvent.Resize:
                self.overlay.resize(self.size())
        return super().eventFilter(obj, event)

    def resizeEvent(self, event):
        super().resizeEvent(event)
        self.overlay.resize(self.size())

    def mousePressEvent(self, event):
        self.last_pos = event.position().toPoint()
        if event.button() == Qt.LeftButton:
            self.drag_mode = 'rotate'
        elif event.button() == Qt.MiddleButton:
            self.drag_mode = 'pan'
        elif event.button() == Qt.RightButton:
            self.drag_mode = 'dolly'
        self.container.setFocus()

    def mouseReleaseEvent(self, event):
        self.drag_mode = None

    def mouseMoveEvent(self, event):
        if not self.drag_mode:
            return
        pos = event.position().toPoint()
        dx = pos.x() - self.last_pos.x()
        dy = pos.y() - self.last_pos.y()
        self.last_pos = pos

        if self.drag_mode == 'rotate':
            sens = 0.005
            self.cam_theta -= dx * sens
            self.cam_phi   += dy * sens
            self.update_camera()

        elif self.drag_mode == 'pan':
            right, up, _ = self.camera_axes()
            scale = self.cam_r * 0.002
            self.cam_target[0] -= (right[0] * dx + up[0] * -dy) * scale
            self.cam_target[1] -= (right[1] * dx + up[1] * -dy) * scale
            self.cam_target[2] -= (right[2] * dx + up[2] * -dy) * scale
            self.update_camera()

        elif self.drag_mode == 'dolly':
            scale = 0.01
            self.cam_r *= (1.0 + dy * scale)
            self.update_camera()

    def wheelEvent(self, event):
        delta = event.angleDelta().y() / 120.0
        self.cam_r *= (1.0 - delta * 0.1)
        self.update_camera()

    def keyPressEvent(self, event):
        key = event.key()
        if key == Qt.Key_Escape:
            QApplication.quit()
            return
        elif key == Qt.Key_Home:
            self.first_file()
        elif key == Qt.Key_End:
            self.last_file()
        elif key == Qt.Key_PageUp:
            self.prev_file()
        elif key == Qt.Key_PageDown:
            self.next_file()
        elif key == Qt.Key_F2:
            self.rename_current_file()
        else:
            super().keyPressEvent(event)

    # ---------- rename ----------
    def rename_current_file(self):
        if not os.path.exists(self.current_file):
            QMessageBox.warning(self, "重新命名", "目前檔案不存在。")
            return
        folder = os.path.dirname(self.current_file)
        base = os.path.basename(self.current_file)
        stem, ext = os.path.splitext(base)

        new_stem, ok = QInputDialog.getText(self, "重新命名", "新檔名（不含副檔名）：", text=stem)
        if not ok or not new_stem.strip():
            return
        new_name = new_stem.strip() + ext
        new_path = os.path.join(folder, new_name)

        if os.path.exists(new_path):
            QMessageBox.warning(self, "重新命名", "已存在相同檔名。")
            return
        try:
            os.rename(self.current_file, new_path)
        except Exception as e:
            QMessageBox.critical(self, "重新命名失敗", f"{e}")
            return

        # 更新清單與目前索引
        self.current_file = new_path
        self.files = list_3d_files(self.folder)
        try:
            idx = [os.path.abspath(p) for p in self.files].index(os.path.abspath(new_path))
        except ValueError:
            idx = 0
        self.set_current_by_index(idx)

# ------------------------ vector math helpers ------------------------
def subv(a, b):
    return [a[0]-b[0], a[1]-b[1], a[2]-b[2]]

def addv(a, b):
    return [a[0]+b[0], a[1]+b[1], a[2]+b[2]]

def dot(a, b):
    return a[0]*b[0]+a[1]*b[1]+a[2]*b[2]

def cross(a, b):
    return [
        a[1]*b[2]-a[2]*b[1],
        a[2]*b[0]-a[0]*b[2],
        a[0]*b[1]-a[1]*b[0]
    ]

def norm(a):
    return math.sqrt(dot(a, a))

def normalize(a):
    n = norm(a)
    if n < 1e-8:
        return [0.0, 0.0, 1.0]
    return [a[0]/n, a[1]/n, a[2]/n]

# ------------------------ application bootstrap ------------------------
def pick_start_file():
    dlg = QFileDialog()
    dlg.setWindowTitle("選擇 3D 模型（OBJ/FBX）")
    dlg.setFileMode(QFileDialog.ExistingFile)
    dlg.setNameFilters(["3D Models (*.obj *.fbx)", "OBJ (*.obj)", "FBX (*.fbx)", "All Files (*.*)"])
    if dlg.exec():
        files = dlg.selectedFiles()
        if files:
            return files[0]
    return None

def main():
    # Windows: DPI 感知（避免高 DPI 模糊）
    if sys.platform.startswith("win"):
        try:
            ctypes.windll.shcore.SetProcessDpiAwareness(1)
        except Exception:
            pass

    app = QApplication(sys.argv)
    app.setApplicationName("3D Viewer")

    # 選擇檔案
    start_file = None
    if len(sys.argv) >= 2:
        candidate = sys.argv[1]
        if os.path.isfile(candidate) and os.path.splitext(candidate)[1].lower() in SUPPORTED_EXTS:
            start_file = candidate
    if not start_file:
        start_file = pick_start_file()
    if not start_file:
        print("未選擇檔案，結束。")
        return

    w = Viewer(start_file)
    w.resize(QSize(1600, 1200))
    w.show()

    sys.exit(app.exec())

if __name__ == "__main__":
    main()

